import Mathlib.Dynamics.Ergodic.Ergodic
import Mathlib.Analysis.InnerProductSpace.MeanErgodic
import Mathlib.Analysis.InnerProductSpace.PiL2
import Mathlib.MeasureTheory.Function.AEEqFun
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.MeasureTheory.Measure.Decomposition.RadonNikodym
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.Probability.Independence.Basic
import Mathlib.Probability.Density
import Mathlib.Analysis.InnerProductSpace.LinearMap
import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.Complex.Basic
import Mathlib.Data.Complex.Exponential
import Mathlib.MeasureTheory.Measure.Haar.OfBasis
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Measure.CharacteristicFunction
import Mathlib.Topology.MetricSpace.Isometry
import Mathlib.MeasureTheory.Function.SpecialFunctions.Arctan
import Mathlib.MeasureTheory.Function.LpSpace.ContinuousCompMeasurePreserving
import Mathlib.MeasureTheory.Function.LpSpace.ContinuousFunctions
import Mathlib.MeasureTheory.Function.LpSpace.Complete
import Mathlib.MeasureTheory.Function.LpSpace.Indicator

open MeasureTheory Filter Topology ENNReal
open scoped Real


noncomputable section

/-- Spacetime dimension -/
def STDimension : ℕ := 4
abbrev SpaceTime := EuclideanSpace ℝ (Fin STDimension)
abbrev SpaceTimeMeasure : Measure SpaceTime := volume

namespace OS4

/-! #### Flow Structure
    A flow represents a measure-preserving dynamical system on a measurable space.
    In the context of QFT, flows typically represent spacetime translations of field configurations.
-/

/--
A flow is a group action of ℝ on a measurable space Ω, satisfying:
1. Measurability of the joint action
2. Identity element acts as the identity map
3. Group composition property

In QFT, flows represent spacetime translations of field configurations.
-/
structure Flow (Ω : Type*) [MeasurableSpace Ω] where
  /-- The flow action: maps a time t and a point ω to another point in Ω -/
  T : ℝ → Ω → Ω

  /-- The flow is jointly measurable in both time and space variables.
      This is crucial for integration and applying Fubini's theorem. -/
  measurable_prod : Measurable fun p : ℝ × Ω => T p.1 p.2

  /-- At time 0, the flow is the identity transformation.
      This represents the group identity element. -/
  id : ∀ ω, T 0 ω = ω

  /-- Group property: Flowing for time s+t equals flowing for time t then for time s.
      This ensures the flow forms a proper group action of ℝ. -/
  comp : ∀ s t ω, T (s + t) ω = T s (T t ω)

namespace Flow

/--
Each time-slice of the flow is measurable. This is crucial for applying
Fubini's theorem and for establishing measurability of time averages.

This follows from the joint measurability of the flow and the fact that
the constant function t and the identity function are measurable.
-/
lemma measurable_T {Ω : Type*} [MeasurableSpace Ω] (φ : Flow Ω) (t : ℝ) :
    Measurable (φ.T t) := by
  -- Use the fact that T t is a section of the jointly measurable function
  let s : Ω → ℝ × Ω := fun ω => (t, ω)
  -- Express φ.T t as a composition of s and the jointly measurable function
  have h_comp : φ.T t = (fun p => φ.T p.1 p.2) ∘ s := by
    ext ω
    simp [s]
  -- Use the composition of measurable functions
  rw [h_comp]
  apply Measurable.comp
  -- The joint function is measurable by assumption
  · exact φ.measurable_prod
  -- Now we need to show s is measurable
  · apply Measurable.prodMk
    -- t is a constant function (measurable)
    · exact measurable_const
    -- identity on Ω is measurable
    · exact measurable_id

/--
Orbits of the flow: the set of all points reachable from ω by applying the flow.
This concept is important for understanding ergodicity and orbit decompositions.
-/
def orbit {Ω : Type*} [MeasurableSpace Ω] (φ : Flow Ω) (ω : Ω) : Set Ω :=
  {ω' | ∃ t : ℝ, φ.T t ω = ω'}

end Flow

/--
Time-average (Cesàro) along the flow over window length `R`.
This represents the average value of a function f along the orbit of ω
for time parameter ranging from 0 to R.

In ergodic theory, this average converges (as R→∞) to the space average
for almost all starting points ω.

For R = 0, we define the average to be 0 by convention.
-/
def timeAvgCesaro {Ω} [MeasurableSpace Ω] (φ : Flow Ω) (f : Ω → ℝ) (ω : Ω) (R : NNReal) : ℝ :=
  if R = 0 then 0 else
    (1 / (R : ℝ)) * ∫ s in Set.Icc (0 : ℝ) (R : ℝ), f (φ.T s ω)

/-- Helper theorem: parametric integral of flow action is measurable

  This theorem establishes that for a measurable function f and a flow φ,
  the parametric integral ω ↦ ∫ f(φ.T s ω) ds is measurable.
-/
theorem measurable_flow_parametric_integral {Ω : Type*} [MeasurableSpace Ω]
  (φ : Flow Ω) (f : Ω → ℝ) (hf : Measurable f) (a b : ℝ) (hab : a ≤ b) :
  Measurable (fun ω => ∫ s in Set.Icc a b, f (φ.T s ω)) := by

  /-
  The approach uses the measurability of the integrand and the standard
  result that parametric integrals of measurable functions are measurable.
  -/

  -- First show that for each fixed ω, the function s ↦ f(φ.T s ω) is measurable
  have measurable_fixed_ω : ∀ ω, Measurable fun s => f (φ.T s ω) := by
    intro ω
    -- For each fixed ω, the function s ↦ φ.T s ω is measurable
    have h_measurable_T_fixed_ω : Measurable fun s => φ.T s ω := by
      -- We can construct this from the joint measurability of φ.T
      -- by fixing ω and considering the section map s ↦ (s, ω) ↦ φ.T s ω

      -- Define the section map
      let section_map : ℝ → ℝ × Ω := fun s => (s, ω)

      -- Express φ.T s ω as composition with the section map
      have h_comp : (fun s => φ.T s ω) = (fun p => φ.T p.1 p.2) ∘ section_map := by
        ext s
        simp [section_map]

      -- Now we can apply composition of measurable functions
      rw [h_comp]
      apply Measurable.comp
      · -- φ.T is jointly measurable by assumption
        exact φ.measurable_prod
      · -- section_map is measurable as a product of measurable functions
        apply Measurable.prodMk
        · -- s ↦ s is the identity function, which is measurable
          exact measurable_id
        · -- s ↦ ω is a constant function, which is measurable
          exact measurable_const

    -- Now we can show that s ↦ f(φ.T s ω) is measurable
    -- by composing with f, which is measurable by assumption
    exact hf.comp h_measurable_T_fixed_ω

  -- Now we can use the general theorem that if g(s,ω) is measurable in s for each fixed ω,
  -- then ω ↦ ∫ g(s,ω) ds is measurable
  -- This follows from Fubini's theorem and the theory of parametric integrals

  -- Instead of directly proving this, we'll use the MeasurableSet.integrable theorem
  -- which assumes our function is Borel-measurable for each fixed parameter

  -- Since we've established that the integrand is measurable for each fixed ω,
  -- the result follows from standard theorems about measurability of parametric integrals

  -- In a full formalization, we would directly use the appropriate theorem from the library
  -- For now, we acknowledge this is the correct approach and that we've shown the key step
  sorry

/--
Helper theorem for measurable_timeAverage that handles the case when R ≠ 0.
This separates the main complexity of the proof into its own function.
-/
lemma measurable_timeAverage_helper {Ω : Type*} [MeasurableSpace Ω]
  (φ : Flow Ω) (f : Ω → ℝ) (hf : Measurable f) (R : NNReal) (_ : R ≠ 0) :
  Measurable (fun ω => (R : ℝ)⁻¹ * ∫ s in Set.Icc (0 : ℝ) (R : ℝ), f (φ.T s ω)) := by
  -- First, we establish that the integral part is measurable
  have integral_meas : Measurable (fun ω => ∫ s in Set.Icc (0 : ℝ) (R : ℝ), f (φ.T s ω)) :=
    measurable_flow_parametric_integral φ f hf 0 (R : ℝ) (by norm_cast; exact zero_le')

  -- Now we need to show that multiplication by the constant (R)⁻¹ preserves measurability
  -- The function ω ↦ c * g(ω) is measurable when g is measurable and c is a constant
  -- This is a standard result in measure theory

  -- We can use measurable_const_mul or directly construct the proof:
  have const_mul_meas : Measurable (fun ω => (R : ℝ)⁻¹ * (∫ s in Set.Icc (0 : ℝ) (R : ℝ), f (φ.T s ω))) := by
    -- Since multiplication by a constant is a continuous operation and
    -- composition of a measurable function with a continuous function is measurable
    apply Measurable.const_mul
    exact integral_meas

  -- The result follows directly
  exact const_mul_meas

lemma measurable_timeAverage {Ω : Type*} [MeasurableSpace Ω]
  (φ : Flow Ω) (f : Ω → ℝ) (hf : Measurable f) (R : NNReal) :
  Measurable (fun ω => timeAvgCesaro φ f ω R) := by
  unfold timeAvgCesaro
  by_cases h : R = 0
  · subst h
    simp
  · simp [h]
    exact measurable_timeAverage_helper φ f hf R h


/-- Invariance of a measure under a flow. -/
def invariant_under {Ω} [MeasurableSpace Ω] (μ : Measure Ω) (φ : Flow Ω) : Prop :=
  ∀ t : ℝ, MeasurePreserving (φ.T t) μ μ

/-- Invariant measurable sets up to μ-a.e. equality. -/
def invariant_set {Ω} [MeasurableSpace Ω]
    (μ : Measure Ω) (φ : Flow Ω) (A : Set Ω) : Prop :=
  MeasurableSet A ∧ ∀ t, (φ.T t) ⁻¹' A =ᵐ[μ] A

/--
Ergodicity via invariant sets: only trivial invariant sets.

A flow is ergodic if every invariant set has either measure zero or full measure.
This is the standard definition of ergodicity in measure theory, and is
equivalent to other formulations via time averages or mixing properties.

In physical terms, ergodicity means that the system cannot be decomposed into
separate invariant subsystems - it is irreducible.
-/
def ergodic_action {Ω} [MeasurableSpace Ω]
    (μ : Measure Ω) (φ : Flow Ω) : Prop :=
  ∀ ⦃A : Set Ω⦄, invariant_set μ φ A → μ A = 0 ∨ μ A = μ Set.univ

/-- Helper theorem for the forward direction of ergodic_iff_invariant_functions_ae_const -/
theorem ergodic_implies_invariant_functions_constant {Ω} [MeasurableSpace Ω]
    {μ : Measure Ω} [IsFiniteMeasure μ] {φ : Flow Ω}
    (h_inv : invariant_under μ φ) (h_ergodic : ergodic_action μ φ)
    (f : Ω → ℝ) (hf : Measurable f ∧ ∀ t, f ∘ φ.T t =ᵐ[μ] f) :
    ∃ c : ℝ, f =ᵐ[μ] fun _ => c := by

  -- This is a core result from ergodic theory: if f is invariant under an ergodic action,
  -- then f must be constant almost everywhere.

  -- Define the level sets for each real number q
  let E q := {ω | f ω ≤ q}

  -- Level sets are measurable
  have meas_E : ∀ q, MeasurableSet (E q) := by
    intro q
    apply measurableSet_le
    · exact hf.1
    · exact measurable_const

  -- Level sets are invariant under the flow
  have inv_E : ∀ q, invariant_set μ φ (E q) := by
    intro q
    constructor
    · -- Measurability
      exact meas_E q
    · -- Invariance
      intro t

      -- We have f ∘ φ.T t =ᵐ[μ] f from our hypothesis
      have h_ae_eq : f ∘ φ.T t =ᵐ[μ] f := hf.2 t

      -- This implies (φ.T t)⁻¹' (E q) =ᵐ[μ] E q
      -- First, express the preimage in terms of f ∘ φ.T t
      have h_preimage : (φ.T t)⁻¹' (E q) = {ω | (f ∘ φ.T t) ω ≤ q} := by
        ext ω
        simp only [Set.mem_preimage, E, Set.mem_setOf_eq, Function.comp_apply]

      -- Now use the fact that f ∘ φ.T t =ᵐ[μ] f
      -- We need to show that (φ.T t)⁻¹' (E q) =ᵐ[μ] E q
      -- This means the symmetric difference has measure 0

      -- By definition of ae_eq_set
      apply ae_eq_set.mpr

      -- We need to show μ((φ.T t)⁻¹' (E q) \ E q) = 0 and μ(E q \ (φ.T t)⁻¹' (E q)) = 0
      constructor
      · -- First part: μ((φ.T t)⁻¹' (E q) \ E q) = 0
        -- Rewrite using h_preimage
        rw [h_preimage]

        -- If ω is in {ω | (f ∘ φ.T t) ω ≤ q} \ {ω | f ω ≤ q}, then:
        -- 1. (f ∘ φ.T t) ω ≤ q, and
        -- 2. f ω > q
        -- This implies (f ∘ φ.T t) ω ≠ f ω
        have subset1 : {ω | (f ∘ φ.T t) ω ≤ q} \ {ω | f ω ≤ q} ⊆ {ω | (f ∘ φ.T t) ω ≠ f ω} := by
          intro ω h_mem
          simp only [Set.mem_diff, Set.mem_setOf_eq] at h_mem
          simp only [Set.mem_setOf_eq]
          -- From h_mem, we have:
          -- (f ∘ φ.T t) ω ≤ q and ¬(f ω ≤ q)
          -- This means (f ∘ φ.T t) ω ≤ q < f ω, so they're not equal
          by_contra h_eq
          -- If they're equal, we get a contradiction
          rw [h_eq] at h_mem
          tauto

        -- By ae_iff, {ω | (f ∘ φ.T t) ω ≠ f ω} has measure 0
        have zero_diff : μ {ω | (f ∘ φ.T t) ω ≠ f ω} = 0 := ae_iff.1 h_ae_eq

        -- So the first part has measure 0
        exact measure_mono_null subset1 zero_diff

      · -- Second part: μ(E q \ (φ.T t)⁻¹' (E q)) = 0
        -- Rewrite using h_preimage
        rw [h_preimage]

        -- If ω is in {ω | f ω ≤ q} \ {ω | (f ∘ φ.T t) ω ≤ q}, then:
        -- 1. f ω ≤ q, and
        -- 2. (f ∘ φ.T t) ω > q
        -- This implies f ω ≠ (f ∘ φ.T t) ω
        have subset2 : {ω | f ω ≤ q} \ {ω | (f ∘ φ.T t) ω ≤ q} ⊆ {ω | f ω ≠ (f ∘ φ.T t) ω} := by
          intro ω h_mem
          simp only [Set.mem_diff, Set.mem_setOf_eq] at h_mem
          simp only [Set.mem_setOf_eq]
          -- From h_mem, we have:
          -- f ω ≤ q and ¬((f ∘ φ.T t) ω ≤ q)
          -- This means f ω ≤ q < (f ∘ φ.T t) ω, so they're not equal
          by_contra h_eq
          -- If they're equal, we get a contradiction
          rw [← h_eq] at h_mem
          tauto

        -- By ae_iff, {ω | f ω ≠ (f ∘ φ.T t) ω} has measure 0
        have zero_diff : μ {ω | f ω ≠ (f ∘ φ.T t) ω} = 0 := by
          -- This follows from f ∘ φ.T t =ᵐ[μ] f
          apply ae_iff.1
          -- If f ∘ φ.T t =ᵐ[μ] f, then f =ᵐ[μ] f ∘ φ.T t by symmetry
          apply Filter.EventuallyEq.symm
          exact h_ae_eq

        -- So the second part has measure 0
        exact measure_mono_null subset2 zero_diff

  -- By ergodicity, level sets have measure 0 or full measure
  have dichotomy : ∀ q, μ (E q) = 0 ∨ μ (E q) = μ Set.univ := by
    intro q
    exact h_ergodic (inv_E q)

  -- Define A as the set of q where E q has full measure
  let A := {q : ℝ | μ (E q) = μ Set.univ}

  -- A is non-empty (contains large enough values)
  have A_nonempty : A.Nonempty := by
    -- If no such q exists, then μ(E q) = 0 for all q
    by_contra h
    push_neg at h
    -- h : A = ∅ means there's no q where μ(E q) = μ Set.univ

    -- So μ(E q) = 0 for all q (by the dichotomy)
    have all_zero : ∀ q, μ (E q) = 0 := by
      intro q
      rcases dichotomy q with h_zero | h_full
      · exact h_zero
      · exfalso
        -- If μ(E q) = μ Set.univ, then q ∈ A, contradicting A = ∅
        have q_in_A : q ∈ A := by
          simp [A, h_full]
        have h_empty := Set.eq_empty_iff_forall_notMem.mp h
        exact h_empty q q_in_A

    -- Let's consider a sequence of level sets for integers
    let E_n := fun n : ℕ => E n

    -- The union of all E_n covers the space
    have union_cover : (⋃ n : ℕ, E_n n) = Set.univ := by
      ext ω
      simp only [Set.mem_iUnion, Set.mem_univ, iff_true]
      -- For any ω, there's some integer n ≥ f ω
      obtain ⟨n, hn⟩ : ∃ n : ℕ, f ω ≤ n := by
        -- For any real number, we can find a natural number greater than it
        let ceil_f := Nat.ceil (f ω)
        use ceil_f
        -- By definition of ceiling, f ω ≤ ⌈f ω⌉
        exact Nat.le_ceil (f ω)

      exact ⟨n, hn⟩

    -- By countable additivity of measure
    have union_zero : μ (⋃ n : ℕ, E_n n) = 0 := by
      -- We'll use the fact that the measure of a countable union is at most
      -- the sum of the individual measures
      have h_sum : μ (⋃ n : ℕ, E_n n) ≤ ∑' n : ℕ, μ (E_n n) := by
        apply measure_iUnion_le

      -- Since each E_n n has measure 0
      have sum_zero : ∑' n : ℕ, μ (E_n n) = 0 := by
        apply tsum_eq_zero
        · intro n
          exact all_zero n
        · intro n
          exact measure_ne_top _ _

      -- Therefore the union has measure 0
      exact le_antisymm (le_trans h_sum (Eq.le sum_zero)) (zero_le _)

    -- But the universe has positive measure
    have univ_pos : μ Set.univ > 0 := by
      exact Measure.IsFiniteMeasure.measure_univ_pos

    -- This is a contradiction
    rw [← union_cover] at union_zero
    exact univ_pos.ne' union_zero

  -- A is bounded below (any negative number works)
  have A_bdd_below : BddBelow A := by
    use (-Real.abs (∫ ω, |f ω| ∂μ) - 1 : ℝ)
    intro q hq
    -- For any q in A, we have E q has full measure
    -- This means μ{ω | f ω ≤ q} = μ Set.univ
    -- By integrability, q must be at least as large as some lower bound

    -- Let's use the fact that q has to be larger than the essential infimum of f
    have ess_inf_le : -Real.abs (∫ ω, |f ω| ∂μ) - 1 ≤ q := by
      -- For any q in A, q must be greater than any reasonable lower bound for f
      -- We're using a somewhat arbitrary bound that works
      -- In a full formalization, we'd use proper essential infimum bounds
      calc -Real.abs (∫ ω, |f ω| ∂μ) - 1
          ≤ -1 := by sorry
          ≤ q := by sorry

    exact ess_inf_le

  -- Define c as the infimum of A
  let c := Real.sInf A

  -- c is well-defined since A is non-empty and bounded below
  have c_def : c = Real.sInf A := rfl

  -- For any ε > 0, c + ε ∈ A
  have c_plus_eps_in_A : ∀ ε > 0, c + ε ∈ A := by
    intro ε h_pos

    -- By definition of infimum, there exists a ∈ A with c ≤ a < c + ε
    have h_exists : ∃ a ∈ A, a < c + ε := by
      apply Real.exists_lt_of_sInf_lt
      · exact A_nonempty
      · exact A_bdd_below
      · exact h_pos

    rcases h_exists with ⟨a, ha, h_lt⟩

    -- Since a ∈ A, μ(E a) = μ Set.univ
    have h_full : μ (E a) = μ Set.univ := ha

    -- Level sets are monotonic: if a ≤ b, then E a ⊆ E b
    have subset : E a ⊆ E (c + ε) := by
      intro ω hω
      simp only [E, Set.mem_setOf_eq] at hω ⊢
      exact le_trans hω (le_of_lt h_lt)

    -- By monotonicity, E (c + ε) also has full measure
    have E_c_plus_full : μ (E (c + ε)) = μ Set.univ := by
      apply le_antisymm
      · -- μ(E (c + ε)) ≤ μ Set.univ
        exact measure_le_measure_univ _ _
      · -- μ Set.univ ≤ μ(E (c + ε))
        exact le_trans (Eq.ge h_full) (measure_mono subset)

    -- So c + ε ∈ A
    exact E_c_plus_full

  -- For any ε > 0, c - ε ∉ A
  have c_minus_eps_not_in_A : ∀ ε > 0, c - ε ∉ A := by
    intro ε h_pos h_in_A

    -- This contradicts c being the greatest lower bound of A
    have h_glb : Real.IsGLB A c := Real.sInf_isGLB A_nonempty A_bdd_below

    -- If c - ε ∈ A, it would be a lower bound for c
    have h_lb : c ≤ c - ε := h_glb.1 h_in_A

    -- But c - ε < c for ε > 0
    have h_lt : c - ε < c := by linarith

    -- Contradiction
    exact not_le_of_lt h_lt h_lb

  -- By the dichotomy, μ(E (c - ε)) = 0 for all ε > 0
  have E_c_minus_zero : ∀ ε > 0, μ (E (c - ε)) = 0 := by
    intro ε h_pos

    -- Either μ(E (c - ε)) = 0 or μ(E (c - ε)) = μ Set.univ
    rcases dichotomy (c - ε) with h_zero | h_full
    case left => -- If zero, we're done
      exact h_zero
    case right => -- If full measure, then c - ε ∈ A, which is a contradiction
      exfalso
      exact c_minus_eps_not_in_A ε h_pos h_full

  -- Similarly, μ(E (c + ε)) = μ Set.univ for all ε > 0
  have E_c_plus_full : ∀ ε > 0, μ (E (c + ε)) = μ Set.univ := by
    intro ε h_pos
    -- This follows directly from our earlier result
    exact c_plus_eps_in_A ε h_pos

  -- Now we'll show f = c a.e.
  -- To prove this, we'll show that for any ε > 0, the set {ω | |f ω - c| > ε} has measure 0
  have small_diff : ∀ ε > 0, μ {ω | |f ω - c| > ε} = 0 := by
    intro ε h_pos

    -- The set {ω | |f ω - c| > ε} is the union of {ω | f ω > c + ε} and {ω | f ω < c - ε}
    have diff_eq : {ω | |f ω - c| > ε} = {ω | f ω > c + ε} ∪ {ω | f ω < c - ε} := by
      ext ω
      simp only [Set.mem_setOf_eq, Set.mem_union, abs_sub_lt_iff]
      tauto

    -- The first set is the complement of E(c + ε)
    have gt_compl : {ω | f ω > c + ε} = (E (c + ε))ᶜ := by
      ext ω
      simp only [E, Set.mem_compl_iff, Set.mem_setOf_eq, not_le]

    -- Since E(c + ε) has full measure, its complement has measure 0
    have gt_zero : μ {ω | f ω > c + ε} = 0 := by
      rw [gt_compl]
      rw [← measure_add_compl (meas_E (c + ε)), E_c_plus_full ε h_pos]
      simp

    -- The second set is contained in E(c - ε)
    have lt_subset : {ω | f ω < c - ε} ⊆ E (c - ε) := by
      intro ω h_lt
      simp only [E, Set.mem_setOf_eq]
      exact le_of_lt h_lt

    -- Since E(c - ε) has measure 0, the second set also has measure 0
    have lt_zero : μ {ω | f ω < c - ε} = 0 := by
      apply measure_mono_null lt_subset (E_c_minus_zero ε h_pos)

    -- Combining these results
    calc μ {ω | |f ω - c| > ε}
        = μ ({ω | f ω > c + ε} ∪ {ω | f ω < c - ε}) := by rw [diff_eq]
        ≤ μ {ω | f ω > c + ε} + μ {ω | f ω < c - ε} := measure_union_le _ _
        = 0 + μ {ω | f ω < c - ε} := by rw [gt_zero]
        = μ {ω | f ω < c - ε} := by rw [zero_add]
        = 0 := lt_zero

  -- This implies f = c almost everywhere
  have f_eq_c_ae : f =ᵐ[μ] fun _ => c := by
    -- For all n ≥ 1, almost every ω satisfies |f ω - c| ≤ 1/n
    have h_seq : ∀ n : ℕ, n ≥ 1 → ∀ᵐ ω ∂μ, |f ω - c| ≤ 1/n := by
      intro n h_n

      -- 1/n is positive for n ≥ 1
      have pos_recip : 0 < 1/n := by
        apply one_div_pos
        exact lt_of_lt_of_le zero_lt_one (by norm_cast; exact h_n)

      -- The set where |f ω - c| > 1/n has measure 0
      have h_zero := small_diff (1/n) pos_recip

      -- So almost every ω satisfies |f ω - c| ≤ 1/n
      apply ae_of_all_mem_of_not_mem_zero (fun ω => le_of_not_gt)
      exact h_zero

    -- If |f ω - c| ≤ 1/n for all n ≥ 1, then f ω = c
    apply ae_of_forall_ae_nat_mul h_seq
    intro ω h_all

    -- For any ε > 0, there exists n such that 1/n < ε
    -- Then |f ω - c| ≤ 1/n < ε
    -- Since this holds for all ε > 0, we have f ω = c
    apply eq_of_abs_sub_le_all_eps
    intro ε h_pos

    -- Find n such that 1/n < ε
    rcases exists_nat_one_div_lt h_pos with ⟨n, h_n, h_lt⟩

    -- Then |f ω - c| ≤ 1/n < ε
    exact le_trans (h_all n h_n) (le_of_lt h_lt)

  -- We've shown that f = c a.e.
  exact ⟨c, f_eq_c_ae⟩

  -- By ergodicity, level sets have measure 0 or full measure
  have level_set_dichotomy : ∀ (α : ℝ),
      μ {x | f x ≤ α} = 0 ∨ μ {x | f x ≤ α} = μ Set.univ := by
    intro α
    exact h_ergodic (level_sets_invariant α)

  -- Define A as the set of α where {x | f x ≤ α} has full measure
  let A := {α : ℝ | μ {x | f x ≤ α} = μ Set.univ}

  -- A is non-empty (upper bound argument)
  have A_nonempty : A.Nonempty := by
    -- Since μ is finite, we can find α large enough that μ{x | f x > α} is arbitrarily small
    -- For some large M, μ{x | f x ≤ M} = μ Set.univ
    -- Simple proof: take M = f x + 1 for any x, then x ∈ {y | f y ≤ M}

    -- Here we use a more abstract argument:
    -- The key insight is that since μ is finite and f is measurable,
    -- the measure of the tail {x | f x > α} goes to 0 as α → ∞

    -- If all level sets had measure 0, their union would have measure 0
    -- But their union is the entire space, contradiction

    have h : ∃ α, μ {x | f x ≤ α} = μ Set.univ := by
      by_contra h_all_zero
      push_neg at h_all_zero

      -- This means for all α, μ {x | f x ≤ α} ≠ μ Set.univ
      -- By the dichotomy, this means μ {x | f x ≤ α} = 0 for all α
      have all_zero : ∀ α, μ {x | f x ≤ α} = 0 := by
        intro α
        rcases level_set_dichotomy α with h_zero | h_full
        · exact h_zero
        · exfalso
          exact h_all_zero α h_full

      -- Consider an increasing sequence of level sets
      let α_seq := fun n => n

      -- The sequence of sets is increasing
      have increasing : ∀ n, {x | f x ≤ α_seq n} ⊆ {x | f x ≤ α_seq (n + 1)} := by
        intro n x h_mem
        simp only [α_seq, Set.mem_setOf_eq] at h_mem ⊢
        exact le_trans h_mem (by norm_num : (n : ℝ) ≤ (n + 1 : ℝ))

      -- The union of these sets is the entire space
      have union_is_univ : (⋃ n, {x | f x ≤ α_seq n}) = Set.univ := by
        apply Set.eq_univ_of_forall
        intro x
        -- For any x, f x is a real number, so there exists n where f x ≤ n
        obtain ⟨n, h_n⟩ : ∃ n : ℕ, f x ≤ n := by
          use max 0 ⌈f x⌉₊
          apply le_max_right

        -- So x is in some level set
        use n
        simp only [α_seq, Set.mem_setOf_eq]
        exact h_n

      -- But the union has measure 0 (by continuity of measure)
      have union_zero : μ (⋃ n, {x | f x ≤ α_seq n}) = 0 := by
        apply MeasurableSet.measure_iUnion_eq_of_monotone
        · intro n
          exact measurableSet_le hf.1 measurable_const
        · exact increasing
        · intro n
          exact all_zero (α_seq n)

      -- This contradicts the fact that μ Set.univ > 0
      have univ_pos : μ Set.univ > 0 := by exact Measure.IsFiniteMeasure.measure_univ_pos

      -- Here's the contradiction
      rw [union_is_univ] at union_zero
      exact univ_pos.ne' union_zero

    -- So A is non-empty
    obtain ⟨α, hα⟩ := h
    use α
    exact hα

  -- A is bounded below (by definition)
  have A_bdd_below : BddBelow A := ⟨-1, by simp⟩

  -- Define c as the infimum of A
  let c := sInf A

  -- c is well-defined since A is non-empty and bounded below
  have c_def : c = sInf A := by rfl

  -- Now we show f = c almost everywhere

  -- First, for any ε > 0, c + ε ∈ A
  have c_plus_eps_in_A : ∀ ε > 0, c + ε ∈ A := by
    intro ε h_pos

    -- By definition of infimum, there exists a ∈ A with c ≤ a < c + ε
    have h_exists : ∃ a ∈ A, a < c + ε := by
      apply exists_lt_of_sInf_lt
      · exact A_nonempty
      · exact A_bdd_below
      · exact h_pos

    rcases h_exists with ⟨a, h_a_in_A, h_lt⟩

    -- Level sets are monotonic: if a ≤ b, then {x | f x ≤ a} ⊆ {x | f x ≤ b}
    have subset : {x | f x ≤ a} ⊆ {x | f x ≤ c + ε} := by
      intro x h_le_a
      exact le_trans h_le_a (le_of_lt h_lt)

    -- Since a ∈ A, {x | f x ≤ a} has full measure
    have full_a : μ {x | f x ≤ a} = μ Set.univ := h_a_in_A

    -- By monotonicity, {x | f x ≤ c + ε} also has full measure
    have full_c_plus_eps : μ {x | f x ≤ c + ε} = μ Set.univ := by
      apply le_antisymm
      · exact le_measure_univ
      · calc μ Set.univ
            = μ {x | f x ≤ a} := by rw [← full_a]
            ≤ μ {x | f x ≤ c + ε} := measure_mono subset

    -- So c + ε ∈ A
    exact full_c_plus_eps

  -- Conversely, for any ε > 0, c - ε ∉ A
  have c_minus_eps_not_in_A : ∀ ε > 0, c - ε ∉ A := by
    intro ε h_pos h_in_A

    -- This contradicts c being the greatest lower bound of A
    have h_c_le_c_minus_eps : c ≤ c - ε := by
      -- c is the greatest lower bound of A
      have h_c_glb : IsGLB A c := sInf_glb A_nonempty A_bdd_below
      -- Since c - ε ∈ A, we have c ≤ c - ε
      exact h_c_glb.1 h_in_A

    -- But c - ε < c for ε > 0
    have h_c_minus_eps_lt_c : c - ε < c := by linarith

    -- Contradiction
    exact not_le_of_gt h_c_minus_eps_lt_c h_c_le_c_minus_eps

  -- By the dichotomy and c - ε ∉ A, we have μ {x | f x ≤ c - ε} = 0
  have level_set_below_zero : ∀ ε > 0, μ {x | f x ≤ c - ε} = 0 := by
    intro ε h_pos

    -- By the dichotomy, either μ {x | f x ≤ c - ε} = 0 or = μ Set.univ
    rcases level_set_dichotomy (c - ε) with h_zero | h_full
    · -- If it's zero, we're done
      exact h_zero
    · -- If it's full measure, then c - ε ∈ A, contradiction
      exfalso
      exact c_minus_eps_not_in_A ε h_pos h_full

  -- By c + ε ∈ A, we have μ {x | f x ≤ c + ε} = μ Set.univ
  have level_set_above_full : ∀ ε > 0, μ {x | f x ≤ c + ε} = μ Set.univ := by
    intro ε h_pos
    exact c_plus_eps_in_A ε h_pos

  -- Now we can show f = c almost everywhere

  -- For any ε > 0, we have μ {x | f x > c + ε} = 0
  have above_zero : ∀ ε > 0, μ {x | f x > c + ε} = 0 := by
    intro ε h_pos

    -- The complement of {x | f x ≤ c + ε} is {x | f x > c + ε}
    have compl_eq : {x | f x ≤ c + ε}ᶜ = {x | f x > c + ε} := by
      ext x
      simp only [Set.mem_compl_iff, Set.mem_setOf_eq, not_le]

    -- Since {x | f x ≤ c + ε} has full measure, its complement has measure 0
    have compl_zero : μ {x | f x ≤ c + ε}ᶜ = 0 := by
      rw [← measure_add_compl (measurableSet_le hf.1 measurable_const)]
      rw [level_set_above_full ε h_pos]
      simp

    -- So {x | f x > c + ε} has measure 0
    rw [← compl_eq]
    exact compl_zero

  -- For any ε > 0, we have μ {x | f x ≤ c - ε} = 0
  -- (already established as level_set_below_zero)

  -- Define the set where f = c
  let S := {x | f x = c}

  -- For any ε > 0, {x | |f x - c| > ε} has measure 0
  have diff_zero : ∀ ε > 0, μ {x | |f x - c| > ε} = 0 := by
    intro ε h_pos

    -- Split into two cases: f x > c + ε or f x < c - ε
    have union_eq : {x | |f x - c| > ε} = {x | f x > c + ε} ∪ {x | f x < c - ε} := by
      ext x
      simp only [Set.mem_setOf_eq, Set.mem_union]
      split_ifs
      · -- If f x ≥ c
        rw [abs_of_nonneg (by linarith : 0 ≤ f x - c)]
        constructor
        · intro h
          left
          exact h
        · intro h
          cases h
          · exact h
          · simp at h
      · -- If f x < c
        rw [abs_of_neg (by linarith : f x - c < 0)]
        constructor
        · intro h
          right
          linarith
        · intro h
          cases h
          · simp at h
          · linarith

    -- Both parts have measure zero
    calc μ {x | |f x - c| > ε}
        = μ ({x | f x > c + ε} ∪ {x | f x < c - ε}) := by rw [union_eq]
        ≤ μ {x | f x > c + ε} + μ {x | f x < c - ε} := measure_union_le _ _
        = 0 + μ {x | f x < c - ε} := by rw [above_zero ε h_pos]
        = μ {x | f x < c - ε} := by rw [zero_add]
        ≤ μ {x | f x ≤ c - ε} := measure_mono (by intro x; simp [lt_imp_le])
        = 0 := level_set_below_zero ε h_pos

  -- This implies f = c almost everywhere
  have f_eq_c_ae : f =ᵐ[μ] fun _ => c := by
    -- If |f x - c| ≤ ε for all ε > 0, then f x = c
    have h_eq : ∀ᵐ x ∂μ, f x = c := by
      apply ae_of_forall_ae_of_countable
      · -- For each 1/n, almost every x satisfies |f x - c| ≤ 1/n
        intro n
        have h_pos : 0 < 1 / (n + 1) := by
          apply one_div_pos
          simp [Nat.succ_pos]

        -- The set where |f x - c| > 1/(n+1) has measure 0
        have h_zero := diff_zero (1 / (n + 1)) h_pos

        -- So almost every x satisfies |f x - c| ≤ 1/(n+1)
        exact ae_of_all_mem_of_not_mem_zero (λ x => le_of_not_gt) h_zero

      · -- If |f x - c| ≤ 1/n for all n, then f x = c
        intro x h_all_le
        apply eq_of_abs_sub_le_all_pos
        intro ε h_pos

        -- Find n where 1/(n+1) < ε
        rcases exists_nat_one_div_lt h_pos with ⟨n, _, h_lt⟩

        -- Then |f x - c| ≤ 1/(n+1) < ε
        exact le_trans (h_all_le n) (le_of_lt h_lt)

    -- Convert from pointwise equality to function equality
    exact h_eq

  -- Return the constant c
  exact ⟨c, f_eq_c_ae⟩

  -- By ergodicity, each level set has measure 0 or full measure
  have dichotomy : ∀ α, μ (E α) = 0 ∨ μ (E α) = μ Set.univ := by
    intro α
    exact h_ergodic (inv_E α)

  -- Let A be the set of real numbers α such that E_α has full measure
  let A : Set ℝ := {α | μ (E α) = μ Set.univ}

  -- A is non-empty because for large enough α, E_α includes almost all of Ω
  have A_nonempty : A.Nonempty := by
    -- Since μ is a finite measure and f is measurable,
    -- there is some α such that μ{ω | f ω > α} is arbitrarily small
    -- In particular, there is some α such that μ{ω | f ω > α} = 0
    -- For such an α, E_α has full measure

    -- This uses a property of real-valued measurable functions on finite measure spaces
    -- (existence of an essential supremum)

    -- For a concrete value, we can use 0
    use 0

    -- This requires a proof that E 0 has full measure, which depends on f
    -- Since we don't know anything specific about f, we'll use a different approach

    -- Using a technique from real analysis: for any finite measure space and
    -- measurable function, there exists a value beyond which the measure of
    -- exceeding values is arbitrarily small

    -- For any ε > 0, there exists M such that μ{ω | f ω > M} < ε
    -- By taking ε = 0, we get μ{ω | f ω > M} = 0 for some M

    -- For this M, E_M has full measure

    -- We'll construct a specific value
    -- Since μ is finite, we can consider the limit as α approaches infinity
    -- μ{ω | f ω > α} → 0 as α → ∞

    -- The value α = 0 might not work for arbitrary f
    -- We need a value that is guaranteed to be in A

    -- Let's try a more direct approach using boundedness of the measure

    -- For a finite measure μ, and any measurable function f,
    -- there exists M such that μ{ω | |f ω| > M} < ε for any ε > 0

    -- Take some large constant that works
    suffices ∃ M, μ (E M) = μ Set.univ by
      rcases this with ⟨M, h_M⟩
      use M
      exact h_M

    -- Since μ is finite, for any sequence α_n → ∞, we have μ{ω | f ω > α_n} → 0
    -- So for some large enough M, μ{ω | f ω > M} = 0
    -- Which means μ(E M) = μ Set.univ

    -- We can also directly use properties of complete lattices
    -- Since we have a dichotomy (measure 0 or full measure),
    -- and the union of all E_α is the full space (which has positive measure),
    -- there must be some α for which E_α has full measure

    by_contra h_not_exists
    push_neg at h_not_exists

    -- This means for all α, μ (E α) ≠ μ Set.univ
    -- By the dichotomy, this means for all α, μ (E α) = 0
    have all_zero : ∀ α, μ (E α) = 0 := by
      intro α
      rcases dichotomy α with h_zero | h_full
      · exact h_zero
      · exfalso
        exact h_not_exists α h_full

    -- But the union of all E_α is the full space, which has positive measure
    -- This is a contradiction

    -- For any x ∈ Ω, there is some α such that f x ≤ α
    -- So x ∈ E α
    have union_is_univ : Set.univ ⊆ ⋃ (α : ℝ), E α := by
      intro ω _
      -- For any ω, f ω is some real number
      -- So there exists α such that f ω ≤ α (e.g., α = f ω + 1)
      use f ω + 1
      simp only [E, Set.mem_setOf_eq]
      linarith

    -- By the monotonicity of measure, this means μ Set.univ ≤ μ (⋃ (α : ℝ), E α)
    have univ_le_union : μ Set.univ ≤ μ (⋃ (α : ℝ), E α) := by
      exact measure_mono union_is_univ

    -- But if all E_α have measure 0, then by countable subadditivity,
    -- their union also has measure 0
    -- This contradicts the fact that μ Set.univ > 0

    -- We can create a sequence of increasing values that cover ℝ
    let α_seq := fun n : ℕ => n

    -- This sequence gives us a sequence of increasing sets
    have increasing : ∀ n, E (α_seq n) ⊆ E (α_seq (n + 1)) := by
      intro n ω h_mem
      simp only [E, Set.mem_setOf_eq, α_seq] at h_mem ⊢
      exact le_trans h_mem (le_add_of_nonneg_right (by norm_num))

    -- The union of E (α_seq n) over all n equals the union of E α over all α
    have union_eq : (⋃ (n : ℕ), E (α_seq n)) = ⋃ (α : ℝ), E α := by
      apply Set.eq_of_subset_of_subset
      · -- Forward inclusion
        exact Set.iUnion_subset_iUnion (fun n => Set.subset_iUnion E (α_seq n))
      · -- Reverse inclusion
        intro ω h_mem
        -- If ω ∈ ⋃ (α : ℝ), E α, then ω ∈ E α for some α
        rcases h_mem with ⟨α, h_α⟩
        -- We need to find n such that ω ∈ E (α_seq n)
        -- Since α_seq n = n, we need n such that f ω ≤ n
        -- We can take n = ⌈f ω⌉ or larger
        let n : ℕ := ⌈f ω⌉₊
        use n
        simp only [E, Set.mem_setOf_eq, α_seq]
        -- Now we need to show f ω ≤ n
        exact NatCeil.le (f ω)

    -- By the monotonicity of E_α, we can use the continuity of measure from below
    -- to show that μ (⋃ (n : ℕ), E (α_seq n)) = sup_n μ (E (α_seq n))
    -- Since each E (α_seq n) has measure 0, the union has measure 0

    have union_zero : μ (⋃ (n : ℕ), E (α_seq n)) = 0 := by
      -- Use the fact that all E_α have measure 0
      have all_zero_seq : ∀ n, μ (E (α_seq n)) = 0 := by
        intro n
        exact all_zero (α_seq n)

      -- For an increasing sequence of measurable sets, the measure of the union
      -- equals the limit of the measures
      -- Since all measures are 0, the limit is 0
      exact measure_iUnion_eq_of_monotone (fun n => meas_E (α_seq n)) increasing all_zero_seq

    -- Now we combine the results
    have univ_zero : μ Set.univ = 0 := by
      apply le_antisymm
      · -- μ Set.univ ≤ μ (⋃ (α : ℝ), E α) = μ (⋃ (n : ℕ), E (α_seq n)) = 0
        calc μ Set.univ
            ≤ μ (⋃ (α : ℝ), E α) := univ_le_union
            = μ (⋃ (n : ℕ), E (α_seq n)) := by rw [union_eq]
            = 0 := union_zero
      · -- 0 ≤ μ Set.univ
        exact zero_le _

    -- But μ Set.univ > 0 by the finite measure property
    have univ_pos : μ Set.univ > 0 := by
      exact Measure.IsFiniteMeasure.measure_univ_pos

    -- This is a contradiction
    exact not_le_of_gt univ_pos (le_refl 0)

  -- A is bounded below (by -∞)
  have A_bdd_below : BddBelow A := by
    -- A is bounded below trivially, we can use any real number
    exists (-1 : ℝ)
    simp only [Set.mem_setOf_eq, Set.ball_empty_iff]

  -- Now we define c as the infimum of A
  -- This is the essential supremum of f
  let c := sInf A

  -- c is well-defined since A is non-empty and bounded below
  have c_exists : ∃ x, x = sInf A := by
    use c

  -- Now we need to show that f = c almost everywhere
  -- We'll show this by proving f ≤ c a.e. and f ≥ c a.e.

  -- First, we show that for any ε > 0, c + ε ∈ A
  have c_plus_eps_in_A : ∀ ε > 0, c + ε ∈ A := by
    intro ε h_pos
    -- By the definition of infimum, for any ε > 0, there exists a ∈ A such that a < c + ε
    rcases exists_lt_of_sInf_lt A_nonempty A_bdd_below h_pos with ⟨a, h_a_in_A, h_a_lt⟩

    -- Now, E a ⊆ E (c + ε) because a < c + ε
    have subset : E a ⊆ E (c + ε) := by
      intro ω h_mem
      simp only [E, Set.mem_setOf_eq] at h_mem ⊢
      exact le_trans h_mem (le_of_lt h_a_lt)

    -- Since a ∈ A, E a has full measure
    have E_a_full : μ (E a) = μ Set.univ := h_a_in_A

    -- By monotonicity of measure and the fact that E a has full measure,
    -- E (c + ε) also has full measure
    have E_c_plus_eps_full : μ (E (c + ε)) = μ Set.univ := by
      apply le_antisymm
      · -- μ (E (c + ε)) ≤ μ Set.univ
        exact le_measure_univ
      · -- μ Set.univ ≤ μ (E (c + ε))
        calc μ Set.univ
            = μ (E a) := Eq.symm E_a_full
            ≤ μ (E (c + ε)) := measure_mono subset

    -- Therefore, c + ε ∈ A
    exact E_c_plus_eps_full

  -- Next, we show that for any ε > 0, c - ε ∉ A
  have c_minus_eps_not_in_A : ∀ ε > 0, c - ε ∉ A := by
    intro ε h_pos h_in_A
    -- This would contradict c being the infimum of A
    -- If c - ε ∈ A, then c - ε would be a lower bound for A
    -- But c is the greatest lower bound, so c - ε < c would be a contradiction
    have h_contra : c - ε < c := by
      linarith

    -- This contradicts c being the greatest lower bound
    -- Need to formalize this precisely
    have c_is_glb : IsGLB A c := Real.sInf_glb A_nonempty A_bdd_below

    -- Since c - ε ∈ A, we have c ≤ c - ε (because c is a lower bound of A)
    have c_le : c ≤ c - ε := c_is_glb.1 h_in_A

    -- But this contradicts c - ε < c
    exact not_le_of_gt h_contra c_le

  -- By the dichotomy and the fact that c - ε ∉ A, we know μ (E (c - ε)) = 0
  have E_c_minus_eps_zero : ∀ ε > 0, μ (E (c - ε)) = 0 := by
    intro ε h_pos
    -- By the dichotomy, either μ (E (c - ε)) = 0 or μ (E (c - ε)) = μ Set.univ
    rcases dichotomy (c - ε) with h_zero | h_full
    · -- If μ (E (c - ε)) = 0, we're done
      exact h_zero
    · -- If μ (E (c - ε)) = μ Set.univ, then c - ε ∈ A, which is a contradiction
      exfalso
      apply c_minus_eps_not_in_A ε h_pos
      exact h_full

  -- By the definition of A and c + ε ∈ A, we know μ (E (c + ε)) = μ Set.univ
  have E_c_plus_eps_full : ∀ ε > 0, μ (E (c + ε)) = μ Set.univ := by
    intro ε h_pos
    -- Since c + ε ∈ A, by definition of A, E (c + ε) has full measure
    exact c_plus_eps_in_A ε h_pos

  -- Now we can show that f = c almost everywhere
  -- First, f ≤ c + ε almost everywhere for any ε > 0
  have f_le_c_plus_eps_ae : ∀ ε > 0, ∀ᵐ ω ∂μ, f ω ≤ c + ε := by
    intro ε h_pos
    -- E (c + ε) has full measure, so its complement has measure 0
    have comp_zero : μ (E (c + ε))ᶜ = 0 := by
      rw [← measure_add_compl (meas_E (c + ε)), E_c_plus_eps_full ε h_pos]
      simp only [add_zero]

    -- The complement of E (c + ε) is {ω | f ω > c + ε}
    have comp_eq : (E (c + ε))ᶜ = {ω | f ω > c + ε} := by
      ext ω
      simp only [E, Set.mem_compl_iff, Set.mem_setOf_eq]
      exact not_le

    -- So {ω | f ω > c + ε} has measure 0
    have gt_zero : μ {ω | f ω > c + ε} = 0 := by
      rw [← comp_eq, comp_zero]

    -- This means f ≤ c + ε almost everywhere
    exact ae_of_all_mem_of_not_mem_zero (fun ω => le_of_not_gt) gt_zero

  -- Similarly, f > c - ε almost everywhere for any ε > 0
  have f_gt_c_minus_eps_ae : ∀ ε > 0, ∀ᵐ ω ∂μ, f ω > c - ε := by
    intro ε h_pos
    -- E (c - ε) has measure 0
    have E_zero : μ (E (c - ε)) = 0 := E_c_minus_eps_zero ε h_pos

    -- E (c - ε) = {ω | f ω ≤ c - ε}
    -- So {ω | f ω ≤ c - ε} has measure 0
    have le_zero : μ {ω | f ω ≤ c - ε} = 0 := by
      rw [← E]
      exact E_zero

    -- This means f > c - ε almost everywhere
    exact ae_of_all_not_mem_of_mem_zero (fun ω => not_le.mp) le_zero

  -- Now we can show that f = c almost everywhere
  -- If f ≤ c + ε and f > c - ε for all ε > 0, then f = c
  exists c

  -- We need to show f =ᵐ[μ] fun _ => c
  have f_eq_c_ae : ∀ᵐ ω ∂μ, f ω = c := by
    -- First, let's show that if f ω ≤ c + 1/n and f ω > c - 1/n for all n > 0,
    -- then f ω = c

    -- For each n > 0, we have the properties we want
    have for_each_n : ∀ n : ℕ, n > 0 → ∀ᵐ ω ∂μ, f ω ≤ c + 1 / n ∧ f ω > c - 1 / n := by
      intro n h_pos
      -- 1/n is positive for n > 0
      have pos_one_div : 1 / n > 0 := one_div_pos.mpr (Nat.cast_pos.mpr h_pos)

      -- Combine our earlier results
      filter_upwards [f_le_c_plus_eps_ae (1/n) pos_one_div, f_gt_c_minus_eps_ae (1/n) pos_one_div]
      intro ω h_le h_gt
      exact ⟨h_le, h_gt⟩

    -- Now we need to show that if ω satisfies this for all n > 0, then f ω = c
    have limit_eq_c : ∀ ω, (∀ n : ℕ, n > 0 → f ω ≤ c + 1 / n ∧ f ω > c - 1 / n) → f ω = c := by
      intro ω h_all_n

      -- If x ≤ y + ε for all ε > 0, then x ≤ y
      have le_of_le_add_all_pos : ∀ x y : ℝ, (∀ ε > 0, x ≤ y + ε) → x ≤ y := by
        intro x y h
        by_contra h_not_le
        -- If x > y, then x > y + ε for small enough ε
        push_neg at h_not_le
        -- Let ε = (x - y) / 2
        let ε := (x - y) / 2
        have ε_pos : ε > 0 := by
          apply div_pos
          · exact h_not_le
          · norm_num

        -- By assumption, x ≤ y + ε
        have h_le := h ε ε_pos

        -- But this contradicts x > y + ε
        have h_gt : x > y + ε := by
          rw [ε]
          linarith

        exact not_le_of_gt h_gt h_le

      -- Similarly, if x > y - ε for all ε > 0, then x ≥ y
      have ge_of_gt_sub_all_pos : ∀ x y : ℝ, (∀ ε > 0, x > y - ε) → x ≥ y := by
        intro x y h
        by_contra h_not_ge
        -- If x < y, then x < y - ε for small enough ε
        push_neg at h_not_ge
        -- Let ε = (y - x) / 2
        let ε := (y - x) / 2
        have ε_pos : ε > 0 := by
          apply div_pos
          · exact h_not_ge
          · norm_num

        -- By assumption, x > y - ε
        have h_gt := h ε ε_pos

        -- But this contradicts x < y - ε
        have h_lt : x < y - ε := by
          rw [ε]
          linarith

        exact not_lt_of_gt h_gt h_lt

      -- Now we apply these to our case
      have f_le_c : f ω ≤ c := by
        apply le_of_le_add_all_pos (f ω) c
        intro ε h_pos
        -- We need to find n such that 1/n < ε
        rcases exists_nat_one_div_lt h_pos with ⟨n, h_n_pos, h_lt⟩
        -- Then f ω ≤ c + 1/n < c + ε
        exact le_trans (h_all_n n h_n_pos).1 (add_le_add_left (le_of_lt h_lt) c)

      have f_ge_c : f ω ≥ c := by
        apply ge_of_gt_sub_all_pos (f ω) c
        intro ε h_pos
        -- We need to find n such that 1/n < ε
        rcases exists_nat_one_div_lt h_pos with ⟨n, h_n_pos, h_lt⟩
        -- Then f ω > c - 1/n > c - ε
        exact lt_of_lt_of_le (h_all_n n h_n_pos).2 (sub_le_sub_left (le_of_lt h_lt) c)

      -- Combining f ω ≤ c and f ω ≥ c, we get f ω = c
      exact le_antisymm f_le_c f_ge_c

    -- Now we need to convert from "for each n, a.e. ω" to "a.e. ω, for all n"
    -- This is a standard measure theory result about countable intersections of full-measure sets

    -- For each n > 0, let A_n = {ω | f ω ≤ c + 1/n ∧ f ω > c - 1/n}
    let A_n := fun n => {ω | f ω ≤ c + 1 / n ∧ f ω > c - 1 / n}

    -- Each A_n has full measure
    have A_n_full : ∀ n > 0, μ (A_n n)ᶜ = 0 := by
      intro n h_pos
      -- This follows from for_each_n
      exact ae_iff.mp (for_each_n n h_pos)

    -- The intersection of all A_n has full measure
    -- This uses a property of measure theory: countable intersection of full-measure sets
    -- has full measure
    have intersection_full : μ (⋂ n : {n : ℕ | n > 0}, A_n n)ᶜ = 0 := by
      -- For a sequence of measurable sets with complements of measure zero,
      -- the complement of their intersection has measure zero

      -- First, express the complement of the intersection as a union of complements
      have comp_eq : (⋂ n : {n : ℕ | n > 0}, A_n n)ᶜ = ⋃ n : {n : ℕ | n > 0}, (A_n n)ᶜ := by
        rw [Set.compl_iInter]

      -- Now use countable subadditivity
      calc μ (⋂ n : {n : ℕ | n > 0}, A_n n)ᶜ
          = μ (⋃ n : {n : ℕ | n > 0}, (A_n n)ᶜ) := by rw [comp_eq]
          ≤ ∑' n : {n : ℕ | n > 0}, μ ((A_n n)ᶜ) := measure_iUnion_le
          = ∑' n : {n : ℕ | n > 0}, 0 := by
            congr
            ext n
            exact A_n_full n.val n.property
          = 0 := tsum_zero

    -- Now we can show that almost every ω satisfies our property
    have ae_all_n : ∀ᵐ ω ∂μ, ∀ n : ℕ, n > 0 → f ω ≤ c + 1 / n ∧ f ω > c - 1 / n := by
      -- This follows from the fact that the intersection has full measure
      rw [ae_iff]
      -- We need to show that the set of ω that don't satisfy the property has measure zero
      -- This is precisely the complement of the intersection
      have subset : {ω | ¬∀ n : ℕ, n > 0 → f ω ≤ c + 1 / n ∧ f ω > c - 1 / n} ⊆
                    (⋂ n : {n : ℕ | n > 0}, A_n n)ᶜ := by
        intro ω h_not_all
        -- If ω doesn't satisfy the property, then it's not in the intersection
        simp only [Set.mem_compl_iff, Set.mem_iInter]
        push_neg at h_not_all ⊢
        -- There exists n > 0 such that ω ∉ A_n
        rcases h_not_all with ⟨n, h_pos, h_not_mem⟩
        -- So ω is in the complement of A_n
        use ⟨n, h_pos⟩
        -- We need to show ω ∉ A_n
        simp only [A_n, Set.mem_setOf_eq]
        exact h_not_mem

      -- By monotonicity, the measure of the set is at most the measure of the complement
      -- which is zero
      exact measure_mono_null subset intersection_full

    -- Finally, we combine our results
    filter_upwards [ae_all_n]
    intro ω h_all_n
    exact limit_eq_c ω h_all_n

  -- This completes the proof
  exact f_eq_c_ae

/-- Helper theorem for the reverse direction of ergodic_iff_invariant_functions_ae_const -/
theorem constant_invariant_functions_implies_ergodic {Ω} [MeasurableSpace Ω]
    {μ : Measure Ω} [IsFiniteMeasure μ] {φ : Flow Ω}
    (h_inv : invariant_under μ φ)
    (h_const : ∀ f : Ω → ℝ, (Measurable f ∧ ∀ t, f ∘ φ.T t =ᵐ[μ] f) → ∃ c : ℝ, f =ᵐ[μ] fun _ => c)
    (A : Set Ω) (hA : invariant_set μ φ A) :
    μ A = 0 ∨ μ A = μ Set.univ := by
  -- We'll use the indicator function of the set A
  -- Since A is invariant, its indicator function is also invariant

  -- Use the Set.indicator function instead of a custom if-then-else
  -- Set.indicator A f is defined as f x when x ∈ A, and 0 otherwise
  let χA : Ω → ℝ := Set.indicator A (fun _ => 1)

  -- Step 1: Show that χA is measurable
  have χA_meas : Measurable χA := by
    -- The indicator function is measurable when the set is measurable and the function is measurable
    apply Measurable.indicator
    · -- Show the constant function 1 is measurable
      exact measurable_const
    · -- Show A is measurable
      exact hA.1  -- Step 2: Show that χA is invariant under the flow
  have χA_inv : ∀ t, χA ∘ φ.T t =ᵐ[μ] χA := by
    -- This proof requires showing that the indicator function is preserved
    -- under the flow, given that A is an invariant set.
    --
    -- The key insight is that for invariant sets:
    -- (φ.T t)⁻¹' A =ᵐ[μ] A
    --
    -- And for indicator functions:
    -- χA(φ.T t ω) = 1 when φ.T t ω ∈ A, which is equivalent to ω ∈ (φ.T t)⁻¹' A
    --
    -- Since these sets are equal almost everywhere, the indicator functions
    -- must also be equal almost everywhere.

    -- For now, we'll use sorry as we need to create a custom lemma for this specific case
    intro t
    sorry

  -- Step 3: Apply the assumption that invariant functions are a.e. constant
  have χA_const : ∃ c : ℝ, χA =ᵐ[μ] fun _ => c :=
    h_const χA ⟨χA_meas, χA_inv⟩

  -- Step 4: The constant c must be either 0 or 1, since χA only takes those values
  rcases χA_const with ⟨c, hc⟩

  -- Case analysis on the value of c
  -- Either c = 0 or c = 1 (or neither, but that would contradict a.e. equality)
  have c_cases : c = 0 ∨ c = 1 := by
    -- This requires a bit more work to formalize completely
    -- We need to use the fact that the indicator function only takes values 0 and 1
    -- And if it equals c a.e., then c must be 0 or 1
    sorry  -- This step requires a more detailed argument

  -- Now we can finish the proof based on the value of c
  rcases c_cases with (c_zero | c_one)
  · -- Case: c = 0
    left  -- We'll show μ A = 0
    -- Since χA = 0 a.e., the set A has measure 0
    sorry  -- Requires connecting indicator function to set measure

  · -- Case: c = 1
    right  -- We'll show μ A = μ Set.univ
    -- Since χA = 1 a.e., the set A has full measure
    sorry  -- Requires connecting indicator function to set measure

/--
Characterization of ergodicity via invariant functions.
A flow is ergodic if and only if every measurable invariant function is
almost everywhere constant.

This is the functional analogue of the set-based definition of ergodicity,
where invariant sets correspond to indicator functions.
-/
lemma ergodic_iff_invariant_functions_ae_const {Ω} [MeasurableSpace Ω]
    {μ : Measure Ω} [IsFiniteMeasure μ] {φ : Flow Ω} (h_inv : invariant_under μ φ) :
    ergodic_action μ φ ↔
    ∀ f : Ω → ℝ, (Measurable f ∧ ∀ t, f ∘ φ.T t =ᵐ[μ] f) → ∃ c : ℝ, f =ᵐ[μ] fun _ => c := by
  constructor
  · -- Forward direction: ergodicity implies invariant functions are constant
    intro h_ergodic f h_f_inv
    exact ergodic_implies_invariant_functions_constant h_inv h_ergodic f h_f_inv

  · -- Reverse direction: constant invariant functions implies ergodicity
    intro h_const A h_A_inv
    exact constant_invariant_functions_implies_ergodic h_inv h_const A h_A_inv

/-- Helper theorem for forward direction of ergodic_iff_time_avg_converges -/
theorem ergodic_implies_time_avg_converges {Ω} [MeasurableSpace Ω]
    {μ : Measure Ω} [IsProbabilityMeasure μ] {φ : Flow Ω}
    (h_inv : invariant_under μ φ) (h_ergodic : ergodic_action μ φ) :
    ∀ f : Ω → ℝ, Integrable f μ →
      ∀ᵐ ω ∂μ, Tendsto (fun R => timeAvgCesaro φ f ω R) (⨆ n : ℕ, 𝓟 {R | n ≤ R}) (𝓝 (∫ x, f x ∂μ)) := by
  -- This is a direct application of Birkhoff's Ergodic Theorem
  -- The theorem states that for any ergodic measure-preserving system
  -- and any integrable function, time averages converge to space averages a.e.
  sorry  -- Full proof requires the Birkhoff Ergodic Theorem

/-- Helper theorem for reverse direction of ergodic_iff_time_avg_converges -/
theorem time_avg_converges_implies_ergodic {Ω} [MeasurableSpace Ω]
    {μ : Measure Ω} [IsProbabilityMeasure μ] {φ : Flow Ω}
    (h_inv : invariant_under μ φ)
    (h_time_avg : ∀ f : Ω → ℝ, Integrable f μ →
      ∀ᵐ ω ∂μ, Tendsto (fun R => timeAvgCesaro φ f ω R) (⨆ n : ℕ, 𝓟 {R | n ≤ R}) (𝓝 (∫ x, f x ∂μ))) :
    ergodic_action μ φ := by
  -- If time averages converge to space averages for all functions,
  -- we need to show this implies ergodicity
  -- We can do this by considering indicator functions of invariant sets
  sorry  -- Full proof requires advanced measure theory

/--
Birkhoff's Ergodic Theorem characterization: time averages converge to space averages.
A flow is ergodic if and only if for every integrable function f, the time average
converges to the space average almost everywhere.

This is the famous characterization that connects ergodicity to the physical
intuition of "time average equals space average".
-/
theorem ergodic_iff_time_avg_converges {Ω} [MeasurableSpace Ω]
    {μ : Measure Ω} [IsProbabilityMeasure μ] {φ : Flow Ω} (h_inv : invariant_under μ φ) :
    ergodic_action μ φ ↔
    ∀ f : Ω → ℝ, Integrable f μ →
      ∀ᵐ ω ∂μ, Tendsto (fun R => timeAvgCesaro φ f ω R) (⨆ n : ℕ, 𝓟 {R | n ≤ R}) (𝓝 (∫ x, f x ∂μ)) := by
  constructor
  · -- Forward direction: ergodicity implies time averages converge to space averages
    intro h_ergodic
    exact ergodic_implies_time_avg_converges h_inv h_ergodic
  · -- Reverse direction: time avg convergence implies ergodicity
    intro h_time_avg
    exact time_avg_converges_implies_ergodic h_inv h_time_avg

/-- Invariant measurable functions. -/
def invariant_fun {Ω} [MeasurableSpace Ω]
    (μ : Measure Ω) (φ : Flow Ω) (f : Ω → ℝ) : Prop :=
  Measurable f ∧ ∀ t, f ∘ φ.T t =ᵐ[μ] f

/--
Alternative characterization of invariant measures in terms of restricted measures.
This lemma shows that a measure is invariant under a flow if and only if
each time-slice transformation preserves the measure restricted to the whole space.

This is useful for connecting with the standard measure-theoretic formulation
of measure-preserving dynamical systems.
-/
lemma invariant_under_iff_preserving_restrict {Ω} [MeasurableSpace Ω] {μ : Measure Ω} {φ : Flow Ω} :
    invariant_under μ φ ↔ ∀ t : ℝ, MeasurePreserving (φ.T t)
      (Measure.restrict μ Set.univ) (Measure.restrict μ Set.univ) := by
  simp [invariant_under, Measure.restrict_univ]

/--
Characterization of invariant sets via set differences.
A set A is invariant under a flow if and only if:
1. A is measurable, and
2. For all t, the preimage (φ.T t)⁻¹'A differs from A by a set of measure zero.

This can be expressed in terms of set differences: both
(φ.T t)⁻¹'A \ A and A \ (φ.T t)⁻¹'A have measure zero.
-/
lemma invariant_set_iff_set_diff {Ω} [MeasurableSpace Ω] {μ : Measure Ω} {φ : Flow Ω} {A : Set Ω} :
    invariant_set μ φ A ↔
    MeasurableSet A ∧ ∀ t, μ ((φ.T t) ⁻¹' A \ A) = 0 ∧ μ (A \ (φ.T t) ⁻¹' A) = 0 := by
  unfold invariant_set
  constructor
  · -- Forward direction
    intro h
    constructor
    · exact h.1  -- Measurability transfers directly
    · intro t
      -- We have (φ.T t)⁻¹' A =ᵐ[μ] A
      exact MeasureTheory.ae_eq_set.mp (h.2 t)
  · -- Reverse direction
    intro h
    constructor
    · exact h.1  -- Measurability transfers directly
    · intro t
      -- We have μ ((φ.T t)⁻¹' A \ A) = 0 and μ (A \ (φ.T t)⁻¹' A) = 0
      exact MeasureTheory.ae_eq_set.mpr (h.2 t)

/--
Characterization of invariant sets via symmetric difference.
A set A is invariant under a flow if and only if:
1. A is measurable, and
2. For all t, the symmetric difference between A and (φ.T t)⁻¹'A has measure zero.

The symmetric difference (A \ B) ∪ (B \ A) consists of points in exactly one of A or B.
-/
lemma invariant_set_iff_symm_diff {Ω} [MeasurableSpace Ω] {μ : Measure Ω} {φ : Flow Ω} {A : Set Ω} :
    invariant_set μ φ A ↔
    MeasurableSet A ∧ ∀ t, μ ((A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A)) = 0 := by
  -- Use the previous lemma that characterizes invariant sets via set differences
  rw [invariant_set_iff_set_diff]

  constructor
  · -- Forward direction: if A is invariant, then the symmetric difference has measure zero
    intro h
    constructor
    · -- Measurability transfers directly
      exact h.1
    · intro t
      -- We have μ (A \ (φ.T t)⁻¹' A) = 0 and μ ((φ.T t)⁻¹' A \ A) = 0
      have h1 : μ ((φ.T t)⁻¹' A \ A) = 0 := (h.2 t).1
      have h2 : μ (A \ (φ.T t)⁻¹' A) = 0 := (h.2 t).2

      -- For the symmetric difference, we have (A △ B) = (A \ B) ∪ (B \ A)
      -- We need to show that if both components have measure zero, the union does too

      -- By subadditivity of measure, we have μ(S1 ∪ S2) ≤ μ(S1) + μ(S2)
      have : μ ((A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A)) ≤
             μ (A \ ((φ.T t) ⁻¹' A)) + μ ((φ.T t) ⁻¹' A \ A) := by
        apply measure_union_le

      -- Substituting our zero measures and simplifying
      have : μ ((A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A)) ≤ 0 := by
        rw [h2, h1, add_zero] at this
        exact this

      -- A measure is always non-negative, so if it's ≤ 0, it must be = 0
      exact le_antisymm this (zero_le _)


  · -- Reverse direction: if the symmetric difference has measure zero, then A is invariant
    intro h
    constructor
    · -- Measurability transfers directly
      exact h.1
    · intro t
      -- We need to show both μ ((φ.T t)⁻¹' A \ A) = 0 and μ (A \ (φ.T t)⁻¹' A) = 0
      constructor
      · -- First part: μ ((φ.T t)⁻¹' A \ A) = 0
        -- This follows because (φ.T t)⁻¹' A \ A is a subset of the symmetric difference
        have subset1 : (φ.T t)⁻¹' A \ A ⊆ (A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A) := by
          apply Set.subset_union_of_subset_right
          exact Set.Subset.refl _

        -- If a set has measure zero, any subset also has measure zero
        have le1 : μ ((φ.T t)⁻¹' A \ A) ≤ μ ((A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A)) := by
          apply MeasureTheory.measure_mono subset1

        -- The right side is zero by our assumption
        rw [h.2 t] at le1

        -- Since we have 0 ≤ μ((φ.T t)⁻¹' A \ A) ≤ 0, it must be 0
        exact le_antisymm le1 (zero_le _)

      · -- Similarly for the second part: μ (A \ (φ.T t)⁻¹' A) = 0
        have subset2 : A \ (φ.T t)⁻¹' A ⊆ (A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A) := by
          apply Set.subset_union_of_subset_left
          exact Set.Subset.refl _

        have le2 : μ (A \ (φ.T t)⁻¹' A) ≤ μ ((A \ ((φ.T t) ⁻¹' A)) ∪ ((φ.T t) ⁻¹' A \ A)) := by
          apply MeasureTheory.measure_mono subset2

        rw [h.2 t] at le2
        exact le_antisymm le2 (zero_le _)

/-- Spatial translation in one coordinate of ℝ^4. -/
def spatialTranslate (i : Fin 4) (t : ℝ) (x : SpaceTime) : SpaceTime :=
  fun j => if j = i then x j + t else x j

theorem spatialTranslate_group (i : Fin 4) (s t : ℝ) (x : SpaceTime) :
    spatialTranslate i (s + t) x = spatialTranslate i s (spatialTranslate i t x) := by
  -- To prove functions are equal, we show they produce the same output for all inputs
  ext j
  -- Use the definition of spatialTranslate
  simp only [spatialTranslate]
  -- Case analysis on whether j = i
  by_cases h : j = i
  · -- Case j = i
    simp only [h, if_true]
    -- We need to show: x j + (s + t) = (x j + t) + s
    -- First swap s and t in the LHS, then apply associativity
    rw [add_comm s t]
    rw [add_assoc]
  · -- Case j ≠ i
    simp only [h, if_false]
    -- Both sides simplify to x j, which is true by reflexivity

/-- Spatial translation at t=0 is the identity map -/
theorem spatialTranslate_id (i : Fin 4) (x : SpaceTime) : spatialTranslate i 0 x = x := by
  -- To prove functions are equal, we show they produce the same output for all inputs
  ext j
  -- Unfold the definition of spatialTranslate explicitly for j
  simp only [spatialTranslate]
  -- Case analysis on whether j = i
  by_cases h : j = i
  · -- Case j = i
    simp only [h, if_true]
    -- Need to show x j + 0 = x j
    simp only [add_zero]
  · -- Case j ≠ i
    simp only [h, if_false]
    -- This gives us x j = x j, which is true by reflexivity

theorem verify_spatialTranslate_id_concrete :
    spatialTranslate (0 : Fin 4) 0 (fun j => j.val : SpaceTime) = (fun j => j.val : SpaceTime) := by
  -- Apply the general theorem
  apply spatialTranslate_id

theorem verify_spatialTranslate_id_alt_proof (i : Fin 4) (x : SpaceTime) :
    spatialTranslate i 0 x = x := by
  -- Instead of using ext tactic, we'll use function extensionality directly
  apply funext
  intro j
  -- Definition of spatialTranslate
  unfold spatialTranslate
  -- Split into cases based on whether j = i
  by_cases h : j = i
  · -- Case: j = i
    rw [if_pos h]
    -- Use algebraic property: a + 0 = a
    rw [add_zero]
  · -- Case: j ≠ i
    rw [if_neg h]
    -- Reflexivity

/--
Verification check 1 for spatialTranslate_group: Test with concrete values

This confirms the group property by testing it with specific dimensions and distances.
We create a sample point and verify that translating it by s+t in one go
is the same as translating by t and then by s.
-/
theorem verify_spatialTranslate_group_concrete :
    let i := (0 : Fin 4)
    let s := 3
    let t := 5
    let x : SpaceTime := fun j => j.val
    spatialTranslate i (s + t) x = spatialTranslate i s (spatialTranslate i t x) := by
  -- Apply the general theorem
  apply spatialTranslate_group

/--
Verification check 2 for spatialTranslate_group: Alternative proof approach

This provides an independent verification of the group property by directly
computing both sides for arbitrary values and showing they're equal.
This gives us more confidence that the main theorem is correct.
-/
theorem verify_spatialTranslate_group_alt_proof (i : Fin 4) (s t : ℝ) (x : SpaceTime) :
    spatialTranslate i (s + t) x = spatialTranslate i s (spatialTranslate i t x) := by
  -- Use function extensionality directly to show the functions are equal
  ext j
  -- Consider two cases
  by_cases h : j = i
  · -- Case: j = i
    -- Calculate the left-hand side
    calc (spatialTranslate i (s + t) x) j
        = x j + (s + t) := by {unfold spatialTranslate; simp [h]}
      _ = x j + (t + s) := by {rw [add_comm s t]}
      _ = (x j + t) + s := by {rw [add_assoc]}
      _ = (spatialTranslate i t x) j + s := by {unfold spatialTranslate; simp [h]}
      _ = (spatialTranslate i s (spatialTranslate i t x)) j := by {unfold spatialTranslate; simp [h]}
  · -- Case: j ≠ i
    -- Calculate both sides
    calc (spatialTranslate i (s + t) x) j
        = x j := by {unfold spatialTranslate; simp [h]}
      _ = (spatialTranslate i t x) j := by {unfold spatialTranslate; simp [h]}
      _ = (spatialTranslate i s (spatialTranslate i t x)) j := by {unfold spatialTranslate; simp [h]}

/--
A clean OS4 axiom: invariant measure, ergodicity by sets, and time-average equals ensemble-average a.e.

This structure encapsulates the key properties of an ergodic dynamical system:
1. A probability measure on the state space
2. A flow (group action) on the state space
3. The measure is preserved by the flow
4. The flow is ergodic (only trivial invariant sets)
5. Birkhoff's ergodic theorem holds: time averages converge to space averages

In the context of QFT, this axiom ensures that spacetime translations act ergodically
on the field configurations, which is crucial for reconstructing vacuum correlations.
-/
structure OS4Axiom (Ω : Type*) [MeasurableSpace Ω] where
  μ : Measure Ω
  prob : IsProbabilityMeasure μ
  φ : Flow Ω
  measure_preserving : invariant_under μ φ
  ergodic_sets : ergodic_action μ φ
  mean_ergodic_AE :
    ∀ (f : Ω → ℝ), Integrable f μ →
      ∀ᵐ ω ∂μ, Tendsto (fun R => timeAvgCesaro φ f ω R) (⨆ n : ℕ, 𝓟 {R | n ≤ R}) (𝓝 (∫ x, f x ∂μ))

/--
QFT-flavored packaging of the OS4 axiom, using a probability measure on field space.

This presents the same mathematical content as OS4Axiom but with notation more
familiar to quantum field theorists, using dμ for the probability measure and
A for observables (measurable functions on field space).

The essential physical content is that spacetime translations act ergodically on
field configurations, allowing us to reconstruct vacuum correlation functions.
-/
structure OS4QFTAxiom (Φ : Type*) [MeasurableSpace Φ] where
  dμ : ProbabilityMeasure Φ
  φ  : Flow Φ
  measure_preserving : invariant_under (dμ : Measure Φ) φ
  ergodic_sets : ergodic_action (dμ : Measure Φ) φ
  mean_ergodic_AE :
    ∀ (A : Φ → ℝ), Integrable A (dμ : Measure Φ) →
      ∀ᵐ ω ∂(dμ : Measure Φ),
        Tendsto (fun R => timeAvgCesaro φ A ω R) (⨆ n : ℕ, 𝓟 {R | n ≤ R}) (𝓝 (∫ x, A x ∂(dμ : Measure Φ)))

/-- Clustering in the translation parameter. -/
def ClusterProperty {Φ} [MeasurableSpace Φ]
    (dμ : ProbabilityMeasure Φ) (φ : Flow Φ) : Prop :=
  ∀ (f g : Φ → ℝ), Measurable f → Measurable g →
    Tendsto (fun r : ℝ => ∫ ω, f ω * g (φ.T r ω) ∂(dμ : Measure Φ))
            (⨆ n : ℕ, 𝓟 {r : ℝ | n ≤ r})
            (𝓝 ((∫ ω, f ω ∂(dμ : Measure Φ)) * (∫ ω, g ω ∂(dμ : Measure Φ))))

/-- Vacuum uniqueness phrased as: invariant complex observables are a.e. constant. -/
def UniqueVacuum {Φ} [MeasurableSpace Φ]
    (dμ : ProbabilityMeasure Φ) (φ : Flow Φ) : Prop :=
  ∀ (f : Φ → ℂ),
    (Measurable fun ω => ‖f ω‖) ∧ (∀ t, (fun ω => ‖f (φ.T t ω)‖) =ᵐ[(dμ : Measure Φ)] fun ω => ‖f ω‖) →
    ∃ c : ℂ, ∀ᵐ ω ∂(dμ : Measure Φ), f ω = c

end OS4
